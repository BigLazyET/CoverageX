using System.Xml.Linq;

namespace CoverageIncr.Prasers;

public class CoberturaPraser : PraserBase
{
    public override CoverageFormat Format => CoverageFormat.Cobertura;

    public override IEnumerable<ParserResult> Parse(string filePath)
    {
        var elements = GetXElements(filePath, "coverage");
        foreach (var element in elements)
        {
            PreProcess(element);
        }
    }

    /// <summary>
    /// Executes the preprocessing of the report.
    /// </summary>
    /// <param name="element"></param>
    /// <returns></returns>
    public override Task PreProcess(XElement report)
    {
        var modules = report.Descendants("package")
            .ToArray();

        if (modules.Length == 0)
        {
            if (report.Descendants("packages").Elements("class").Any())
            {
                // Fix malformed report files (See issues: #192, #209)
                foreach (var packagesElement in report.Descendants("packages").ToArray())
                {
                    packagesElement.Name = "classes";

                    var parent = packagesElement.Parent;

                    packagesElement.Remove();
                    parent.Add(new XElement("packages",
                        new XElement("package", new XAttribute("name", "AutoGenerated"), packagesElement)));
                }
            }
        }

        var sources = report.Descendants("sources")
            .Elements("source")
            .Select(s => s.Value)
            .Select(s => s.EndsWith(":") ? s + Path.DirectorySeparatorChar : s) // Issue: #115
            .ToArray();

        if (sources.Length == 0)
        {
            return Task.CompletedTask;
        }

        var classes = report.Descendants("package")
            .Elements("classes")
            .Elements("class")
            .ToArray();

        if (sources.Length == 1)
        {
            foreach (var @class in classes)
            {
                var fileNameAttribute = @class.Attribute("filename");

                if (fileNameAttribute.Value.StartsWith("http://") || fileNameAttribute.Value.StartsWith("https://"))
                {
                    continue;
                }

                string sourcePath = sources[0]
                    .Replace('\\', Path.DirectorySeparatorChar)
                    .Replace('/', Path.DirectorySeparatorChar);

                string fileName = fileNameAttribute.Value
                    .Replace('\\', Path.DirectorySeparatorChar)
                    .Replace('/', Path.DirectorySeparatorChar);

                string path = Path.Combine(sourcePath, fileName);
                fileNameAttribute.Value = path;
            }
        }
        else
        {
            foreach (var @class in classes)
            {
                var fileNameAttribute = @class.Attribute("filename");

                if (fileNameAttribute.Value.StartsWith("http://") || fileNameAttribute.Value.StartsWith("https://"))
                {
                    continue;
                }

                foreach (var source in sources)
                {
                    string sourcePath = source
                        .Replace('\\', Path.DirectorySeparatorChar)
                        .Replace('/', Path.DirectorySeparatorChar);

                    string fileName = fileNameAttribute.Value
                        .Replace('\\', Path.DirectorySeparatorChar)
                        .Replace('/', Path.DirectorySeparatorChar);

                    string path = Path.Combine(sourcePath, fileName);

                    if (File.Exists(path))
                    {
                        fileNameAttribute.Value = path;
                        break;
                    }
                }
            }
        }
        
        return Task.CompletedTask;
    }
}